dgs:
  graphql:
    schema-locations:
      - ${classpath*:schemas/**/*.graphql*}

## Server port
server:
  port: 9993
#  servlet:
#    context-path: /graphql

## H2 Configuration
spring:
  output:
    ansi:
      enabled: DETECT #If your terminal supports ANSI, the color output will be used to aid readability. You can set spring.output.ansi.enabled value to either ALWAYS, NEVER or DETECT.
  h2:
    console:
      enabled: true #H2 database has an embedded GUI console for browsing the contents of a database and running SQL queries. By default, the H2 console is not enabled in Spring.
      path: /h2-console
      settings:
        trace: false #we set spring.h2.console.settings.trace to false to prevent trace output
        web-allow-others: false #we can also disable remote access by setting spring.h2.console.settings.web-allow-others to false.
  datasource:
    ## By default, closing the last connection to a database closes the database. For an in-memory database, this means the content is lost. To keep the database open, add ;DB_CLOSE_DELAY=-1 to the database URL. To keep the content of an in-memory database as long as the virtual machine is alive, use jdbc:h2:mem:test;DB_CLOSE_DELAY=-1.
    #url: jdbc:h2:mem:srs-db;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    #url=jdbc:h2:file:/data/demo: #By design, the in-memory database is volatile, and results in data loss after application restart. We can change that behavior by using file-based storage.
    url: jdbc:h2:mem:mydb;DATABASE_TO_UPPER=false #H2 was creating the tables with UPPERCASE names then behaving case-sensitive, even though in all scripts (including in the creation ones) i used lowercase.
    username: admin
    password: pass
    driverClassName: org.h2.Driver
    hikari:
      connection-timeout: 2000
      initialization-fail-timeout: 0
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    defer-datasource-initialization: true #By default, the data.sql script executes before Hibernate initialization. This aligns the script-based initialization with other database migration tools such as Flyway and Liquibase. As we're recreating the schema generated by Hibernate each time, we need to set an additional property. This modifies the default Spring Boot behavior and populates the data after the schema is generated by Hibernate
    show-sql: true
    hibernate:
      ddl-auto: update #set it to 'none' to disable Hibernate automatic schema creation
      ## The below two lines fix a problem with the way Hibernate converts the Java class and field names to table and column names. By default it converts a camel case such as MyTable to snake case like MY_TABLE. We disable that practice and use JPA annotations like @Column and @Table to control the names.
      naming.implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
      naming.physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        #dialect: com.buland.graphql.netflixdgs.springboot.dialect.MyH2Dialect
        use_sql_comments: true
        show_sql: true
        format_sql: true
        globally_quoted_identifiers: true
        enable_lazy_load_no_trans: true
  #sql.init.data-locations=data-h2: data-h2.sql #script to load db

logging:
  #file: /logs/application-debug.log
  #pattern:
    #console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    #file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  level:
    ROOT: INFO
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
